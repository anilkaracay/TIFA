import { ethers, deployments } from "hardhat";

async function main() {
    console.log("Starting Reproduction of Frontend Flow (Amount Fix)...");
    const [deployer] = await ethers.getSigners();

    // 1. Setup
    const poolDep = await deployments.get("FinancingPool");
    const tokenDep = await deployments.get("InvoiceToken");
    const testTokenDep = await deployments.get("TestToken");

    const FinancingPool = await ethers.getContractAt("FinancingPool", poolDep.address);
    const InvoiceToken = await ethers.getContractAt("InvoiceToken", tokenDep.address);
    const TestToken = await ethers.getContractAt("TestToken", testTokenDep.address);

    // 2. Simulate ID Generation (CUID)
    const mockCuid = "cmj1x2y3z0000abcde123456" + Math.floor(Math.random() * 10);
    console.log(`Mock CUID: ${mockCuid}`);

    // Standard encoding (supports up to 31 bytes)
    const usageId = ethers.encodeBytes32String(mockCuid);
    console.log(`Generated Bytes32: ${usageId}`);

    // 3. Mint
    console.log("Minting...");
    const coreData = {
        invoiceId: usageId,
        issuer: deployer.address,
        debtor: deployer.address,
        currency: ethers.ZeroAddress,
        amount: ethers.parseUnits("1000", 18),
        dueDate: Math.floor(Date.now() / 1000) + 86400
    };

    const txMint = await InvoiceToken.mintInvoice(coreData, "http://uri");
    const receipt = await txMint.wait();

    // Get Token ID from receipt (Manual extraction from Transfer event, usually Log 0)
    let tokenId;

    // Find Transfer event
    const transferSig = ethers.id("Transfer(address,address,uint256)");
    const transferLog = receipt.logs.find((l: any) => l.topics[0] === transferSig);

    if (transferLog && transferLog.topics.length === 4) {
        tokenId = BigInt(transferLog.topics[3]); // topic 3 is tokenId
        console.log(`Found Token ID from Transfer: ${tokenId}`);
    } else {
        console.log("Could not find Transfer log. Checking others...");
        const regLog = receipt.logs.find((l: any) => l.topics.length === 4 && l.topics[0] !== transferSig);
        if (regLog) {
            tokenId = BigInt(regLog.topics[2]);
            console.log(`Found Token ID from Registry: ${tokenId}`);
        }
    }

    if (!tokenId) {
        console.error("Token ID not found in logs!");
        return;
    }

    // 4. Approve
    console.log("Approving...");
    await (await InvoiceToken.setApprovalForAll(FinancingPool.target, true)).wait();

    // 5. Lock
    console.log("Locking...");
    try {
        const txLock = await FinancingPool.lockCollateral(usageId, tokenId, deployer.address);
        await txLock.wait();
        console.log("Locked successfully.");
    } catch (e: any) {
        console.error("Lock Failed:", e.message);
        return;
    }

    // 6. Draw Credit
    console.log("Drawing...");
    const amount = ethers.parseUnits("100", 18); // 10%
    try {
        const txDraw = await FinancingPool.drawCredit(usageId, amount, deployer.address);
        await txDraw.wait();
        console.log("Draw Successful!");
    } catch (e: any) {
        console.error("Draw Failed:", e.message);

        console.log("Attempting diagnosis...");
        try {
            const pos = await FinancingPool.getPosition(usageId);
            console.log("Position Exists:", pos.exists);
            console.log("Position Owner:", pos.company);
            console.log("Calculated Max Credit:", pos.maxCreditLine.toString());
            console.log("Requested Amount:", amount.toString());

            // Check liquidity
            const liq = await TestToken.balanceOf(FinancingPool.target);
            console.log("Pool Liquidity:", liq.toString());
        } catch (err) {
            console.error("Diagnosis error:", err);
        }
    }
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
